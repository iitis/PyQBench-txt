\documentclass[preprint,12pt, a4paper, dvipsnames]{elsarticle}

\usepackage{amssymb}

\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{lineno}
\usepackage{listings}

\usepackage{float}

\usepackage{todonotes}
\usepackage{url}

\usepackage{xcolor}

\usepackage{caption}
\usepackage{subcaption}

\definecolor{codegreen}{rgb}{0.25,0.93,0.31}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%
%\lstdefinestyle{mystyle}{
%	backgroundcolor=\color{backcolour},
%	commentstyle=\color{codegreen},
%	keywordstyle=\color{magenta},
%	numberstyle=\tiny\color{codegray},
%	stringstyle=\color{codepurple},
%	basicstyle=\ttfamily\footnotesize,
%	breakatwhitespace=false,
%	breaklines=true,
%	captionpos=b,
%	keepspaces=true,
%	numbers=left,
%	numbersep=5pt,
%	showspaces=false,
%	showstringspaces=false,
%	showtabs=false,
%	tabsize=2
%}
%
%\lstset{style=mystyle}
\lstset{frame=tb,
	language=Python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
%	numberstyle=\color{blue},
%	keywordstyle=\color{blue},
%	commentstyle=\color{PineGreen},
%	stringstyle=\color{ForestGreen},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3,
	escapeinside={@}{@},
%	literate=
%	{0}{{{\color{red}0}}}1
%	{1}{{{\color{red}1}}}1
%	{2}{{{\color{red}2}}}1
%	{3}{{{\color{red}3}}}1
%	{4}{{{\color{red}4}}}1
%	{5}{{{\color{red}5}}}1
%	{6}{{{\color{red}6}}}1
%	{7}{{{\color{red}7}}}1
%	{8}{{{\color{red}8}}}1
%	{9}{{{\color{red}9}}}1
%    {v0}{{{\color{black}v0}}}1 %% we can not style only numeric literals
%    {v1}{{{\color{black}v1}}}1
}
\restylefloat{table}

\newcommand{\eg}{{\emph{e.g.\/}}}
\newcommand{\ie}{{\emph{i.e.\/}}}
\newcommand{\ket}[1]{\ensuremath{|#1\rangle}}
\newcommand{\bra}[1]{\ensuremath{\langle#1|}}
\newcommand{\ketbra}[2]{\ensuremath{\ket{#1}\bra{#2}}}
\newcommand{\proj}[1]{\ensuremath{\ketbra{#1}{#1}}}
\newcommand{\braket}[2]{\ensuremath{\langle{#1}|{#2}\rangle}}
\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\complexity}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\new}[1]{ \textcolor{red}{#1} }
\newcommand{\1}{{\rm 1\hspace{-0.9mm}l}}
\newcommand{\Id}{{\rm 1\hspace{-0.9mm}l}}
\newcommand{\connected}{\sim}
\newcommand{\SPAN}{\mathrm{span}}
\newcommand{\Lrm}{\ensuremath{\mathrm{L}}}
\newcommand{\Urm}{\ensuremath{\mathrm{U}}}
\newcommand{\ee}{\ensuremath{\mathrm{e}}}
\newcommand{\dd}{\ensuremath{\mathrm{d}}}
\newcommand{\ii}{\ensuremath{\mathrm{i}}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\DU}{\mathcal{DU}}
\newcommand{\NOT}{\sigma_x}
\newcommand{\idop}[1][\XX]{\ensuremath{\1_{#1}}}
\newcommand{\diaguni}{\ensuremath{\mathcal{DU}}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\tr}{\mathrm{tr}}
\newcommand{\textapprox}{\raisebox{0.5ex}{\texttildelow}}
\journal{SoftwareX}


\usepackage{amsmath}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{scheme}{Scheme}
\newtheorem{lemma}{Lemma}

\begin{document}

\begin{frontmatter}

\title{PyQBench: a Python library for benchmarking gate-based quantum computers}

\author{Konrad Jałowiecki\corref{cor1}}
\ead{dexter2206@gmail.com}
\cortext[cor1]{Corresponding author}

\author{Paulina Lewandowska}
\author{\L ukasz Pawela}

\address{Institute of Theoretical and Applied Informatics, Polish Academy
	of Sciences, Ba{\l}tycka~5, 44-100 Gliwice, Poland}

\begin{abstract}
We introduce PyQBench, an innovative open-source framework for benchmarking
gate-based quantum computers. PyQBench can benchmark NISQ devices by verifying their capability of
discriminating between two von Neumann measurements. PyQBench offers a simplified, ready-to-use,
command line interface (CLI) for running benchmarks using a predefined parametrized Fourier
family of measurements. For more advanced scenarios, PyQBench offers a way of employing user-defined
measurements instead of predefined ones.

\end{abstract}

\begin{keyword}
Quantum computing \sep
Benchmarking quantum computers \sep
Discrimination of quantum measurements \sep
Discrimination of von Neumann measurements \sep
Open-source \sep
Python programming

\PACS 03.67.-a \sep 03.67.Lx

\MSC 81P68

\end{keyword}

\end{frontmatter}



\section*{Current code version}
\label{}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} & \textbf{Please fill in this
column} \\
\hline
C1 & Current code version & 0.1.0 \\
\hline
C2 & Permanent link to code/repository used for this code version & \url{https://github.com/iitis/PyQBench} \\
\hline
C3 & Code Ocean compute capsule & \todo[inline]{???}\\
\hline
C4 & Legal Code License & Apache License 2.0\\
\hline
C5 & Code versioning system used & git \\
\hline
C6 & Software code languages, tools, and services used & Python, Qiskit, AWS Braket \\
\hline
C7 & Compilation requirements, operating environments \& dependencies &
\texttt{Python >= 3.8}\newline
\texttt{numpy \textapprox= 1.22.0}\newline
\texttt{scipy \textapprox= 1.7.0}\newline
\texttt{pandas \textapprox= 1.5.0}\newline
\texttt{amazon-braket-sdk >= 1.11.1}\newline
\texttt{pydantic \textapprox= 1.9.1}\newline
\texttt{qiskit \textapprox= 0.37.2}\newline
\texttt{mthree \textapprox= 1.1.0}\newline
\texttt{tqdm \textapprox= 4.64.1}\newline
\texttt{pyyaml \textapprox= 6.0}\newline
\texttt{qiskit-braket-provider \textapprox= 0.0.3}\\
\hline
C8 & If available Link to developer documentation/manual &
\url{https://pyqbench.readthedocs.io/en/latest/}\\
\hline
C9 & Support email for questions & \url{dexter2206@gmail.com}\\
\hline
\end{tabular}
\caption{Code metadata}
\label{}
\end{table}


\linenumbers

%% main text

%The permanent link to code/repository or the zip archive should include the
%following requirements:
%
%README.txt and LICENSE.txt.
%
%Source code in a src/ directory, not the root of the repository.
%
%Tag corresponding with the version of the software that is reviewed.
%
%Documentation in the repository in a docs/ directory, and/or READMEs, as
%appropriate.





\section{Motivation and significance}

Noisy Intermediate-Scale Quantum (NISQ)~\cite{preskill} devices are storming the market,
with a wide selection of devices based on different architectures and accompanying software
solutions. Among hardware providers offering public access to their gate--based devices, one could
mention Rigetti \cite{rigetti}, IBM \cite{ibmq}, Oxford Quantum Group \cite{oxforf}, IonQ \cite{ionq} or Xanadu \cite{xanadu}. Other vendors offer devices operating in
different paradigms. Notably, one could mention D-Wave \cite{dwave} and their quantum
annealers, or QuEra devices \cite{quera} based on neural atoms.  Most vendors provide their own software stack and
application programming interface for accessing their devices. To name a few, Rigetti's computers
are available through their Forest SDK \cite{sdk} and PyQuil library \cite{pyquil} and IBM Q \cite{ibmq} computers can be accessed
through Qiskit \cite{qiskit} or IBM Quantum Experience web interface \cite{ibmqplatform}. Some cloud services, like Amazon Braket \cite{amazon}, offer access to several quantum devices under a unified API. On top of that, several
libraries and frameworks can integrate with different hardware vendors. Examples of such frameworks
include IBM Q's Qiskit or Zapata Computing's Orquestra \cite{zapata}.

It is well known that NISQ devices have their limitations \cite{preskillnew}. The question is to what extent those
devices can perform meaningful computations? To answer this question, one has to devise a
methodology for benchmarking them. For gate--based computers, on which this paper focuses, there
already exist several approaches. 
One could mention randomized benchmarking  \cite{knill2008randomized}, benchmarks based on the quantum volume \cite{cross2019validating, moll2018quantum, pelofske2022volume} or or cross-entropy benchmarking \cite{arute2019quantum, neill2018blueprint}.  


In this paper, we introduce yet another method for benchmarking gate--based devices with a simple
operational interpretation. In our method, we test how well the given device can distinguish between
two von Neumann measurements performed in different bases. We implemented our method in an
open-source Python library called PyQBench. The library supports any device available through Qiskit
library, and thus can be used with providers such as IBM Q or Amazon Braket. Along with the library,
the PyQBench package contains a command line tool for running most common benchmarking scenarios. 





\section{Existing benchmarking methodologies and software}
Unsurprisingly, PyQBench is not the only software package for benchmarking gate--based devices.
While we believe that our approach has significant benefits over other benchmarking techniques, for
completeness, in this section we discuss some of the currently available similar software.

Probably the simplest benchmarking method one could devise is simply running known algorithms and
comparing outputs with the expected ones. Analyzing the frequency of the correct outputs, or the
deviation between actual and expected outputs distribution provides then a metric of the performance
of a given device. Libraries such as Munich Quantum Toolkit (MQT) Benchmark library contain
benchmarks leveraging multiple algorithms, such as Shor's algorithm or Grover's algorithm, 
Despite being intuitive and easily interpretable, such benchmarks may have some problems. Most
importantly, they assess the usefulness of a quantum device only for a very particular algorithm,
and it might be hard to extrapolate their results to other algorithms and applications. For
instance, the inability of a device to consistently find factorizations using Shor's algirithms
does not tell anything about its usefulness in Variational Quantum Algorithm's. 

Another possible approach to benchmarking quantum computers is randomized benchmarking
\cite{liu2022sampling, knill2007randomized, wallman2014randomized, helsen2022general,
	cornelissen2021scalable}. In this approach, one samples circuits to be run from some predefined set
of gates (e.g. from the Clifford group) and tests how much the output distribution obtained from the
device running these circuits differs from the ideal one. It is also common to concatenate randomly
chosen circuits with their inverses (which should yield the identity circuit) and run those
concatenated circuits on the device. Libraries implementing this approach include Qiskit \cite{},
\todo[inline]{enumerate other libraries and summary}


\section{Preliminaries and discrimination scheme approach}
This section is divided into two parts.
In Section~\ref{sec:maths}, we introduce the necessary notation and preliminaries needed to understand the concept of PyQBench. Next, in Section~\ref{sec:discrimination-scheme},
we will present a general overview of the discrimination scheme in theoretical terms. We will also mention NISQ devices' limitations and possible practical solutions during implementation process.

\subsection{Mathematical preliminaries}\label{sec:maths}
A general quantum
measurement, that is a positive operator valued measure (POVM) $\PP$ is a
collection of positive semidefinite operators $\{E_1, \ldots, E_m \}$ called
\emph{effects}, which sum up to identity, \ie $ \, \, \sum_{i=1}^m E_i = \1$.
In PyQBench, we are interested only in von Neumann measurements, i.e. measurements
for which all the effects are rank-one projectors. Every such measurement can be
parameterized by a unitary matrix $U$ which effects $\{\proj{u_0}, \ldots, \proj{u_{d-1}}\}$,
are created by taking $\ket{u_i}$ as  $(i+1)$-th column of the unitary matrix $U$.
We will denote von Neumann measurements described by the matrix $U$ by $\PP_{U}$.

Typically, NISQ devices can only perform measurements in computational $Z$-basis.
To perform an arbitrary von Neumann measurement $\PP_{U}$, one has to first apply $U^\dagger$
to the measured system and then follow with $Z$-basis measurement. Hence, the following two
circuits are equivalent.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=1.7]{pics/vonneuman}
	\caption{Decomposition of a von Neumann measurement $\PP_{U}$. }
	\label{fig:vonnneuman}
\end{figure}

Note that the decomposition above is basically a change of basis in which the measurement
is performed.

\subsection{Discrimination scheme}\label{sec:discrimination-scheme}

Without loss of generality, we consider discrimination task between a measurement in the computational
Z-basis ($\PP_\Id$), and an alternative measurement performed in the basis $U$
($\PP_U$)\footnote{Explaining why we can consider only Z-basis and alternative measurement $\PP_{U}$ is beyond
	the scope of this technical documentation. See \cite{puchala2018strategies} if you are interested in
	the explanation.}. In PyQBench, we operate only on two-level systems, but the discrimination scheme,
described in detail in \cite{puchala2018strategies}, makes no assumptions about the dimensionality.

In general, the discrimination scheme, presented in Fig.~\ref{fig:theoretical_scheme}, requires an
auxiliary system of the same dimensionality as the measured one. First, the joint system is prepared in
some state $\ket{\psi_0}$. Then, the unknown measurement is performed on the first part of the
system. Based on its outcome $i$, the final measurement $\mathcal{P}_{V_i}$ is performed to obtain an
outcome $j$. Finally, if $j=0$ we guess that the performed measurement is $\mathcal{P}_U$, otherwise we guess that it was $\mathcal{P}_\Id$.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=1.7]{pics/theoretical_scheme}
	\caption{Theoretical  scheme of discrimination  between von Neumann measurements $\PP_{U}$ and $\PP_\Id$. }
	\label{fig:theoretical_scheme}
\end{figure}

\subsubsection{Limitations of NISQ devices and practical discrimination schemes}

Current NISQ devices are unable to perform conditional measurements, which is the biggest
obstacle to implementing our scheme on real hardware. However, we can adjusting our scheme so that it only uses components available on current devices.
For this purpose, we use two possible options: using a postselection or a direct sum
$V_0^\dagger\oplus V_1^\dagger$.

\begin{scheme}(By using postselection)

	The first idea uses a postselection scheme. Instead of performing a conditional measurement $\PP_{V_k}$, for each
	measurement $\PP_U, \PP_\Id$ to be discriminated and each choice of $k \in \{0, 1\}$ we run circuits presented in Fig. \ref{fig:postselection}.

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=1.7]{pics/postselection_no_channels}

		\caption{
			A schematic representation of the setup for distinguishing
			measurements $\PP_{U}$ and $\PP_{\Id}$ using postselection approach.
		}\label{fig:postselection}
	\end{figure}

The experiments can be grouped into classes identified by tuples of the form
	$(\mathcal{Q}, k, i, j)$, where $\mathcal{Q} \in \{\PP_U, \PP_\Id\}$ denotes the chosen measurement, $k \in \{0,1\}$, $i \in \{0,1\}$ and $j \in \{0,1\}$.
	In postselection approach, we discard all the experiments for which $k \ne i$. Hence, the total number of valid experiments is

	\begin{equation}
	N_\text{total} = \#\{(\QQ, k, i, j): k = i \}.
	\end{equation}

	Finally, we count the valid experiments resulting in successful discrimination.
	If we have chosen $\PP_U$, then we guess correctly iff $j=0$. Similarly, for
	$P_\Id$, we guess correctly iff $j=1$. If we define
	\begin{eqnarray}
	N_{\PP_U} &= \#\{(\mathcal{Q}, k, i, j): \mathcal{Q} = \PP_U, k = i, j = 0\}, \\
	N_{\PP_\Id} &= \#\{(\mathcal{Q}, k, i, j): \mathcal{Q} = \PP_\Id, k = i, j = 1\},
	\end{eqnarray}
	then the empirical success probability can be computed as

	\begin{equation}
	p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{N_{\PP_U} + N_{\PP_\Id}}{N_{\text{total}}}.
	\end{equation}

\end{scheme}

\begin{scheme}(By using direct sum)


The second idea uses the direct sum $V_0^\dagger \oplus V_1^\dagger$ implementation.     Here, instead of performing a conditional
measurement $\PP_{V_k}$, where $k\in \{0,1\}$,  we run circuits presented in	Fig.~\ref{fig:controlled}.

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=1.5]{pics/controlled_unitary}

		\caption{ A schematic representation of the setup for distinguishing
			measurements $\PP_{U}$ and $\PP_{\Id}$ using direct sum.
		}\label{fig:controlled}
	\end{figure}

	In this scheme, the experiment can be characterized by a pair $(\mathcal{Q}, i,j)$, where $\mathcal{Q} = \{ \PP_{U}, \PP_{\Id} \}$. The number of successful trials for $U$ and $\Id$, respectively, can be written  as
	\begin{eqnarray}
	N_{\PP_U} &= \#\{(\mathcal{Q},  i, j): \mathcal{Q} = \PP_U, j = 0\}, \\
	N_{\PP_\Id} &= \#\{(\mathcal{Q},  i, j): \mathcal{Q} = \PP_\Id, j = 1\}.
	\end{eqnarray}
	Then, the probability of correct discrimination between $\PP_{U} $ and $\PP_\Id$ is given by
	\begin{equation}
	p_{\text{succ}} = \frac{N_{\PP_{U}} + N_{\PP_{\Id}}}{N_{\text{total}}},
	\end{equation}
	where $N_{\text{total}}$ is the number of trials.
\end{scheme}




\subsubsection{Optimal discrimination scheme}


The celebrated result by Helstrom~\cite{helstrom1976quantum} gives the optimal  probability of correct discrimination between two quantum measurements, $\PP$  and $\mathcal{Q}$,
in terms of their distance with the use of the diamond norm
\begin{equation}
p_{\text{succ}}(\PP, \mathcal{Q}) =  \frac12 + \frac14 \| \PP - \mathcal{Q} \|_\diamond,
\end{equation}
where
\begin{equation}
\|\PP\|_\diamond = \max_{\| \ket{\psi}\|_1=1} \| \left(\PP \otimes \1\right) (\proj{\psi}) \|_1.
\end{equation}
The quantum state $\ket{\psi}$ which maximizes the diamond norm is called as discriminator.
Furthermore,  thanks to the proof of the Holevo-Helstrom theorem, it is possible to construct the necessary components  ($\ket{\psi_0}$, $V_0$, $V_1$) to create the optimal discrimination strategy.




\section{Discrimination scheme for parameterized Fourier family and implementation}


So far, we only discussed how the discrimination is performed using two different
schemes, assuming that all needed components ($\ket{\psi_0}$, $V_0$, $V_1$) are known. It turned out that the determination of $V_0$ and $V_1$ is a simple task while the discriminator $\ket{\psi_{0}}$ is known. However,
determining the analytical form of the discriminator $\ket{\psi_{0}}$
is, in general, NP-hard problem.
We have found the analytical solution of the discrimination scheme for a particular class of von Neumann measurements.


Here,  we will show how all the necessary ingredients look like for
von Neumann measurements defined by the parameterized Fourier family:

\begin{equation}
U = H
\left(\begin{array}{cc}1&0\\0&e^{i \phi}\end{array}\right)  H^\dagger,
\end{equation}
where $H$ is the Hadamard matrix of dimension two and $\phi \in [0, 2 \pi)$.
In this case, the optimal input state is the Bell state of the form
\begin{equation}
\ket{\psi_{0}} = \frac{1}{\sqrt{2}} \ket{00} + \ket{11}.
\end{equation}
Observe that the discriminator does not depend on the angle $\phi$. 
Nevertheless, for a given angle  $\phi \in  [0, 2 \pi)$,   the unitaries $V_0$,  $V_1$
have the following form
\begin{equation}
V_0 = \left(\begin{array}{cc}i \sin\left( \frac{\pi - \phi}{4} \right)&-i
\cos\left( \frac{\pi - \phi}{4} \right)\\ \cos\left( \frac{\pi -
	\phi}{4}\right)& \sin\left( \frac{\pi - \phi}{4} \right)\end{array}\right),
\end{equation}
\begin{equation}
V_1 = \left(\begin{array}{cc}-i \cos\left(\frac{\pi - \phi}{4}\right) &i
\sin\left( \frac{\pi - \phi}{4}\right)\\\sin\left( \frac{\pi - \phi}{4} \right)
&  \cos\left( \frac{\pi - \phi}{4} \right) \end{array}\right).
\end{equation}
Finally, we have also calculated the theoretical probability of correct discrimination between von Neumann
measurements $\PP_U$ and $\PP_{\Id}$ is given by
\begin{equation}
p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{1}{2} + \frac{|1 - e^{i \phi}  |}{4} .
\end{equation}
More details and proofs of the construction's validity   we can find in the \ref{app:optimal-probability} and \ref{app:optimal-strategy}.

 
 
 \section{Software description}
 \label{}
 This section is divided into two parts.
 In Section~\ref{sec:sortware-functionalities} we present the details of PyQBench functionality. Next, in Section~\ref{sec:sortware-architecture},
 we will give a general overview of the software architecture.




\subsection{Software Functionalities}\label{sec:sortware-functionalities}


In the scope of this Paper, we aim at  exploring ideas revolving around quantum
gate model-inspired computing devices, and assess their feasibility to
benchmark a modern quantum architectures. The main idea that we have envisioned
for this project is  introducing new concepts of benchmarks for NISQ devices
benchmarking. This project aims to characterize the computing power and
investigate possible practical applications of such devices having access by
Amazon Braket.



\subsection{Software Architecture}\label{sec:sortware-architecture}
PyQBench can be used in two different ways:
\begin{itemize}
\item As a library. This way allows for more advanced scripting defining your own measurements scheme.

\item As a CLI tool. This mode of operation trades extensibility for simplicity of usage, as it allows only for running Fourier-discrimination experiments defined with  YAML input files.
\end{itemize}


\section{PyQBench as a library}\label{sec:pyqbench-as-library}
This guide introduces basic concepts needed for using PyQBench as a library from a Python script. In particular, we will consider the following topics:
\begin{enumerate}
\item Defining experiment using circuit components.
\item Assembling circuits needed for given benchmarking scheme.
\item Running experiment on a simulator or a hardware.
\item Obtaining empirical probability of successful discrimination between measurements.
\end{enumerate}

On the conceptual level, every discrimination experiment performed in PyQBench needs the following:
\begin{enumerate}
\item Discriminator, i.e. optimal initial state for the circuit.
\item Unitary $U^\dagger$ defining alternative measurement to be discriminated from the measurement in Z-basis.
\item $V_0^\dagger$ and $V_1^\dagger$, positive and negative parts of optimal measurement from Holevo-Helstrom theorem.
\end{enumerate}

\subsubsection{Example of usage}
In  this example, we will use $U =  H$ (the Hadamard gate).
The explicit formula for discriminator in this model reads
\begin{equation}
\ket{\psi_0} = \frac{1}{\sqrt{2}} (\ket{00} + \ket{11}),
\end{equation}
with corresponding parts of optimal measurement being equal to
\begin{equation}
V_0 =
\left(\begin{array}{cc} \alpha & -\beta\\ \beta & \alpha \end{array}\right),
\end{equation}
and \begin{equation}
V_1 =
\left(\begin{array}{cc} -\beta & \alpha \\ \alpha & \beta \end{array}\right),
\end{equation}
where \begin{equation}
\alpha = \frac{\sqrt{2 - \sqrt{2}}}{2} \cos\left( \frac{3}{8} \pi \right),
\end{equation}
\begin{equation}
\beta  = \frac{\sqrt{2  + \sqrt{2}}}{2} \sin\left( \frac{3}{8} \pi \right).
\end{equation}
As a next step, we need decompose our matrices into actual sequences of gates.
The circuit taking $\ket{00}$ to the Bell state $\ket{\psi_0}$  comprises the Hadamard gate followed by CNOT gate on both qubits (see Fig.~\ref{fig:discriminator}).
\begin{figure}[h!]
	\centering
	\includegraphics[scale=1.7]{pics/discriminator}
	\caption{Decomposition of the discriminator $\ket{\psi_0}$. }
	\label{fig:discriminator}
\end{figure}
For $V_0$ and $V_1$ observe that $V_0 = RY\left(\frac{3}{4} \pi \right) $, where $RY$ is rotation gate around the $Y$ axis defined by
\begin{equation}
RY(\theta) =
\left(\begin{array}{cc} \cos\frac{\theta}{2} & -\sin\frac{\theta}{2} \\ \sin\frac{\theta}{2} & \cos\frac{\theta}{2} \end{array}\right).
\end{equation}
To obtain $V_1$  we need only to swap the columns, which is equivalent to 
\begin{equation}
V_1 =  RY\left(\frac{3}{4} \pi \right) \cdot X.
\end{equation}
Finally, calculate the optimal probability of correct discrimination which is equal to
\begin{equation}
p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{1}{2} + \frac{\sqrt{2}}{4}. 
\end{equation}
The detailed calculation we can see in \ref{app:hadamard}. 
Now we simulate the  theoretical framework using PyQBench. We will start with simulation in Qiskit SDK with Aer simulator. First, we import necessary modules and needed functions from PyQBench.

\begin{lstlisting}[language=Python]
import numpy as np
from qiskit import QuantumCircuit, Aer
from qbench.schemes.postselection import benchmark_using_postselection
from qbench.schemes.direct_sum import benchmark_using_direct_sum
\end{lstlisting}
To run a function from PyQBench, we need to define Qiskit instructions.  We can do so by constructing circuit acting on qubits 0 and 1 and then converting them using \textit{to\_instruction()} method.
\begin{lstlisting}[language=Python, caption= Defining components for Hadamard experiment]
def state_prep():
	circuit = QuantumCircuit(2)
	circuit.h(0)
	circuit.cnot(0, 1)
	return circuit.to_instruction()

def u_dag():
	circuit = QuantumCircuit(1)
	circuit.h(0)
	return circuit.to_instruction()

def v0_dag():
	circuit = QuantumCircuit(1)
	circuit.ry(-np.pi * 3 / 4, 0)
	return circuit.to_instruction()

def v1_dag():
	circuit = QuantumCircuit(1)
	circuit.ry(-np.pi * 3 / 4, 0)
	circuit.x(0)
	return circuit.to_instruction()

def v0_v1_direct_sum_dag():
	circuit = QuantumCircuit(2)
	circuit.ry(-np.pi * 3 / 4, 0)
	circuit.cnot(0, 1)
	return circuit.to_instruction()

\end{lstlisting}
For the purpose of this example,  we run experiments on Qiskit Aer simulator.
\begin{lstlisting}[language=Python, caption= Defining a backend]
simulator = Aer.get_backend("aer_simulator")

\end{lstlisting}
Now running the simulation is as simple as invoking functions imported from PyQBench package.
\begin{lstlisting}[language=Python, caption=Simulation benchmark by using postselection]
postselection_result = benchmark_using_postselection(
	backend=simulator,
	target=0,
	ancilla=1,
	state_preparation=state_prep(),
	u_dag=u_dag(),
	v0_dag=v0_dag(),
	v1_dag=v1_dag(),
	num_shots_per_measurement=10000,
)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Simulation benchmark by using direct sum]
direct_sum_result = benchmark_using_direct_sum(
	backend=simulator,
	target=1,
	ancilla=2,
	state_preparation=state_prep(),
	u_dag=u_dag(),
	v0_v1_direct_sum_dag=v0_v1_direct_sum_dag(),
	num_shots_per_measurement=10000,
)
\end{lstlisting}
Finally, we calculate the empirical probability obtained from postselection and direct sum experiment and calculate the absolute error between analytical and empirical results. 
\begin{lstlisting}[language=Python, caption=Computation of discrimination probability]
p_succ = (2 + np.sqrt(2)) / 4
print(f"Analytical p_succ = {p_succ}")
print(
f"Postselection: p_succ = {postselection_result}, abs. error = {p_succ - postselection_result}"
)
print(f"Direct sum: p_succ = {direct_sum_result}, abs. error = {p_succ - direct_sum_result}")

\end{lstlisting}


\begin{lstlisting}
Analytical p_succ = 0.8535533905932737
Postselection: p_succ = 0.8559797193791593, abs. error = -0.0024263287858855564
Direct sum: p_succ = 0.85605, abs. error = -0.0024966094067262468
\end{lstlisting}


\subsubsection{Gaining more control over the benchmarking process}
In the example presented above we used functions that automate the whole process - from the circuit assembly, through running the simulations to interpreting the results. But what if we want more control over some parts of this process? 
One possibility would be to add some additional parameters to \textit{benchmark\_using\_xyz} functions, but this approach is not scalable. Moreover, there is no way we can anticipate all the possible use cases.
 We decided on another approach.  PyQBench provides functions performing:
\begin{enumerate}
\item assembly of circuits needed for experiment, provided the components discussed above
\item interpretation of the obtained measurements
\end{enumerate}
 The difference between the two approaches is illustrated on the diagrams below.

\begin{figure}[ht!]
	\centering
	\begin{subfigure}[b]{\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{pics/scheme1}
%		\caption{$y=x$}
		\label{fig:simplified}
	\end{subfigure}
	\vfill
	\begin{subfigure}[b]{\textwidth}
		\centering
	\includegraphics[width=0.8\textwidth]{pics/scheme2}
		\label{fig:execution}
	\end{subfigure}
\end{figure}

\pagebreak

By choosing this approach we need to divide the experiment into two parts:
assembling  circuits and running  circuits.

Let us focus only on the postselection case, as the direct sum case is analogous. In addition, we need to import two more functions from PyQBench.
\begin{lstlisting}[language=Python, caption= Assembling circuits]
from qbench.schemes.postselection import (
assemble_postselection_circuits,
compute_probabilities_from_postselection_measurements,
)

circuits = assemble_postselection_circuits(
	target=0,
	ancilla=1,
	state_preparation=state_prep(),
	u_dag=u_dag(),
	v0_dag=v0_dag(),
	v1_dag=v1_dag(),
)

\end{lstlisting}
The function \textit{assemble\_postselection\_circuits} creates all of neceserry circuits as a dictionary. Each informs if the circuit implements $U^\dagger$ or $\Id$ on the target qubit, and which of $V_0$ and
$V_1$ is used.


Now we need to run the circuits. We will run a noisy and noiseless simulation of our circuits. 


\begin{lstlisting}[language=Python, caption=Adding noise model]
from qiskit.providers.aer import noise

error = noise.ReadoutError([[0.75, 0.25], [0.8, 0.2]])

noise_model = noise.NoiseModel()
noise_model.add_readout_error(error, [0])
noise_model.add_readout_error(error, [1])
\end{lstlisting}
Once we have our noise model ready, we can execute our circuits with and without noise. To this end, we will use Qiskit’s execute function. One caveat is that we have to keep track which measurements correspond to which circuit. We do so by fixing an ordering on the keys in \textit{circuits} dictionary.
\begin{lstlisting}[language=Python, caption=Running  circuits]
from qiskit import execute

keys_ordering = ["id_v0", "id_v1", "u_v0", "u_v1"]
all_circuits = [circuits[key] for key in keys_ordering]

counts_noisy = (
	execute(all_circuits, backend=simulator, noise_model=noise_model, shots=10000).result().get_counts()
)

counts_noiseless = execute(all_circuits, backend=simulator, shots=10000).result().get_counts()
\end{lstlisting}
Finally, we compute the success probabilities using  \textit{compute\_probabilities\_from\_\\postselection\_measurements} function.


\begin{lstlisting}[language=Python, caption=Computation probabilities]
prob_succ_noiseless = compute_probabilities_from_postselection_measurements(
	id_v0_counts=counts_noiseless[0],
	id_v1_counts=counts_noiseless[1],
	u_v0_counts=counts_noiseless[2],
	u_v1_counts=counts_noiseless[3],
)


prob_succ_noisy = compute_probabilities_from_postselection_measurements(
	id_v0_counts=counts_noisy[0],
	id_v1_counts=counts_noisy[1],
	u_v0_counts=counts_noisy[2],
	u_v1_counts=counts_noisy[3],
)

\end{lstlisting}
The success probability is 0.8524401115559386. Whereas if we obtain a readout error, the success probability is equal to 0.5017958400693446. 
As expected, noisy simulations gave us results that are further away from the exact ones.
This concludes introduction to PyQBench library.



 
 
\section{PyQBench as a CLI tool}\label{sec:pyqbench-as-cli}
Using PyQBench as a library allows one to conduct arbitrary two-qubit von Neumann measurement experiment. However, as discussed in the previous guide, it requires some amount of boilerplate code.
For a Fourier parametrized family of measurements, PyQBench offers a simplified way of performing the experiment using a Command Line Interface (CLI).
The workflow is describe as a list of steps:

\begin{enumerate}

\item Preparing configuration files describing backend and the experiment scenario.
\item Submitting/running experiments. Depending on the experiment scenario, execution can be synchronous, or asynchronous.
\item (optional) Checking status of the submitted jobs if the execution is asynchronous.
\item For asynchronous jobs, 
resolve jobs into actual measurements.
\item Computing discrimination probabilities and outputting the resulting table.
\end{enumerate} 
\subsubsection{Preparing configuration files}
To prepare configyurartion files we need to define the experiment and the   backend 
which we want to benchmark. Experiments and backends are defined in YAML files. An example experiment definition looks as follows.
\begin{lstlisting}[language=Python, caption=Defining the experiment]
type: discrimination-fourier
qubits:
	- target: 0
	  ancilla: 1
	- target: 1
      ancilla: 2
angles:
	start: 0
	stop: 2 * pi
	num_steps: 3
gateset: ibmq
method: direct_sum
num_shots: 100
\end{lstlisting}


The components of the experiment is as follows:
\begin{itemize}
	\item The \textit{type} describes type of the experiment. Currently, the only option of  \textit{type} is \textit{discrimination-fourier}. 
	\begin{lstlisting}[language=Python]
type: discrimination-fourier
	\end{lstlisting}
	\item The \textit{qubits} list describes pair of qubits on which the experiment should be run. In this example, the benchmark will run on two pairs of qubits. First pair is 0 and 1, second pair is 1 and 2.
\begin{lstlisting}[language=Python]
qubits:
	- target: 0
	  ancilla: 1
	- target: 1
	  ancilla: 2
	\end{lstlisting}
\item The \textit{angles} key describe range of angles for Fourier parametrized family. The range is always uniform, starts at the \textit{start}, ends at \textit{stop} and contains \textit{num\_steps} points, including both start and stop. The start and stop can be arithmetic expressions using \textit{pi} literal. For instance range defined as:  
\begin{lstlisting}[language=Python]
angles:
	start: 0
	stop: 2 *pi
	num_steps: 3
\end{lstlisting}
 would contain three angles $0, \pi$  and $2\pi$.
 \item 
 The \textit{gateset} key describes the gate decomposition of the experiment. The possible options are \textit{[ibmq, lucy, rigetti, generic]}. If the user choose the device-dependent key, that is one of the options \textit{ibmq, lucy, rigetti}, then the experiment will be implemented by using predefined sequence of native gates. If the user choose the \textit{generic} key, then the compiler  will automatically decompose given circuit in the way that is suitable for the device in use.
 \begin{lstlisting}[language=Python]
gateset: ibmq
 \end{lstlisting}
 \item The \textit{method} can take one of two values: \textit{direct\_sum} or \textit{postselection}, and as the name suggests, defines which method is used to implement the experiment.
 \begin{lstlisting}[language=Python]
method: direct_sum
 \end{lstlisting}
 \item The \textit{num\_shots} defines how many shots are performed in the experiment for particular angle, qubit pair and circuit. For the purpose of calculating possible costs, this is how you compute total number of shots and executed circuits. Let $N$ be the number of qubit pairs in \textit{qubits} key and let $M$ be the number of steps defined in the \textit{angles} key. Then number of executed circuits is $2MN$ for the \textit{direct\_sum} method and $4MN$ for the \textit{postselection} method. Each of those circuits is executed \textit{num\_shots} times.
 \begin{lstlisting}[language=Python]
num_shots: 100
 \end{lstlisting}
\end{itemize}

Observe that the experiment file does not specify what backend to use. This way, the same experiment file can be used on multiple backends.
 Different backends may require different information to be used. For instance, IBMQ backends might require hub, group and project, whereas backends from the \textit{Aer} package do not. Hence, the exact format of the YAML file depends on what backend one wants to use. Below we present 
 YAML file defining the IMBQ backend named Quito. 
\begin{lstlisting}[language=Python, caption=IBMQ backend]
name: ibmq_quito
asynchronous: false
provider:
	hub: ibm-q
	group: open
	project: main
\end{lstlisting}


IBMQ backends typically require and access token to IBM Quantum Experience. It would be unsafe to store them in plain text, and therefore the token is configured separately. Before running the experiment, you should place your token in the \textit{IBMQ\_TOKEN} environmental variable.






\subsubsection{Notes on using the asynchronous flag}
In this example, the only key that requires the explanation is \textit{asynchronous} which determines whether experiments will be run asynchronously  (\textit{true}) or not (\textit{false}).
% We recommend setting it to true, unless your experiment is really small (several circuits total). However, some backends may not support asynchronous execution. This might be especially the case with local simulators. 

For asynchronous execution to work, the following conditions have to be met:
\begin{itemize}
\item Jobs returned by the backend have unique \textit{job\_id}, 
\item Job object is retrievable from the backend using \textit{backend.retrieve\_job} method, even from another process (e.g. if the original process running the experiment has finished).
\end{itemize}
Since PyQBench cannot determine if the job retrieval works for given backend, the user is responsible for checking it yourself. 

\todo[inline]{co z tymi sekcjami?}
\subsubsection{Backends obtainable from simple providers???}
\subsubsection{Backends constructed from a simple function call???}
\todo[inline]{co z tymi sekcjami?}

\subsubsection{Running the experiment and collecting measurements data}
After preparing YAML files with defined experiment and backend, 
running the experiment is done by using the following command line invocation:
\begin{lstlisting}[language=Python]
qbench disc-fourier benchmark experiment_file.yml backend_file.yml
\end{lstlisting}
The output file will be printed to stdout. Optionally, the \textit{- -output OUTPUT} flag might be provided to write the output to the \textit{OUTPUT} file instead.
\begin{lstlisting}[language=Python]
qbench disc-fourier benchmark experiment_file.yml backend_file.yml --output async_results.yml
\end{lstlisting}
The result of running the above command can be twofold:
\begin{itemize}
	\item If backend is asynchronous, the output will contain intermediate data containing, amongst others, job$\_$ids correlated with the circuit they correspond to.
	\item If the backend is synchronous, the output will contain measurement data (bitstrings) for each of the circuits run.
\end{itemize}

For synchronous experiment, the part of output looks similar to the one below. The whole YAML file can be seen in \ref{app:example}.
%Consider the particular experiment data
\begin{lstlisting}[language=Python]
data:
- target: 0
  ancilla: 1
  phi: 0.0
  results_per_circuit:
  - name: id
  histogram: {'00': 28, '01': 26, '10': 21, '11': 25}
  mitigation_info:
	target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
	ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
  mitigated_histogram: {'00': 0.2637212373658018, '01': 0.25865061319892463, '10': 0.2067279352110304, '11': 0.2709002142242433}
\end{lstlisting}
	The data includes \textit{target, ancilla, phi},
	and \textit{results\_per\_circuit}.   The first three pieces of information have already been described. The last data  \textit{results\_per\_circuit} gives us 
	the following additional informations: 
	\begin{itemize}
		\item  name: id:  the information which measurement is used during experiment,   $\PP_{U}$ or $\PP_{\Id}$. In this example we consider  $\PP_{\Id}$. 
		\item histogram: {'00': 28, '01': 26, '10': 21, '11': 25}: the dictionary with measurement's outcomes. The keys represent possible measurement oucomes, whereas the values present number of occurrences. 
		\item mitigation\_info:  \textit{system.properties().qubits} contains information on the physical attributes of the qubits. This includes e.g. information about readout error. As shown below, the \textit{readout\_error} is further partitioned into \textit{prob\_meas0\_prep1} and \textit{prob\_meas1\_prep0}, indicating the probability of preparing a given computational basis state, but measuring the orthogonal state.  The readout error is taken to be the average of these two values. Note that \textit{prob\_meas0\_prep1} is usually the dominant factor in the readout error due to relaxation during the measurement process.  ~\cite{mthree, mthreepublication}
		\item mitigated\_histogram:  the histogram with measurement's outcomes after mitigation.
	\end{itemize}

\subsubsection{(Optional) Getting status of asynchronous jobs}
 PyQBench provides also a helper command that will fetch the statuses of asynchronous jobs. The command is:
\begin{lstlisting}[language=Python]
qbench disc-fourier status async_results.yml
\end{lstlisting}
and it will display dictionary with histogram of statuses.

\subsubsection{Resolving asynchronous jobs}
If the status of jobs is \textit{DONE}, we have to obtain measurements from the submitted jobs. This is done using the following command:
\begin{lstlisting}[language=Python]
qbench disc-fourier resolve async-results.yml resolved.yml
\end{lstlisting}
The resolved results, stored in \textit{resolved.yml}, would look just like the experiment was run synchronously. More precisely, we should have a file containing measurement histograms, no matter if we run a synchronous or asynchronous experiment (see \ref{app:example}). Next, we can compute the discrimination probabilities.


\subsubsection{Computing probabilities}
Regardless of whether we use a synchronous or asynchronous approach, we can convert the resulting YML file \textit{results.yml} to a CSV file by creating a result table in which we place the results of discrimination probabilities.
To construct a table with probabilities, you can use the following command
\begin{lstlisting}[language=Python]
qbench disc-fourier tabulate results.yml results.csv 
\end{lstlisting}
A single row for each tuple of \textit{(target, ancilla, phi)}. The \textit{disc\_prob} column will contain the discrimination probability for given configuration. The \textit{mit\_disc\_prob} column contains discrimination probability if Mthree mitigation was applied~\cite{mthree, mthreepublication}.
A sample csv file is provided below:
\begin{figure}[h!]
	\centering
	\includegraphics[scale=1]{results/async_result}
	\caption{Tabulate results}
	\label{fig:tabulateresults}
\end{figure}



\section{Impact}
\todo[inline]{OJCIEC WYKAZ SIE, bo trzeba to dobrze sprzedac, nizej tekst z formatki softwarex co powinna zawierac ta sekcja}
This software has two main contributions.



\textbf{This is the main section of the article and the reviewers weight the
description here appropriately}

Indicate in what way new research questions can be pursued as a result of the
software (if any).

Indicate in what way, and to what extent, the pursuit of existing research
questions is improved (if so).

Indicate in what way the software has changed the daily practice of its users
(if so).

Indicate how widespread the use of the software is within and outside the
intended user group.

Indicate in what way the software is used in commercial settings and/or how it
led to the creation of spin-off companies (if so).

\section{Conclusions}
\label{}

In this study, we develop  a Python library PyQBench, an innovative open-source framework for benchmarking
gate-based quantum computers.


%%%%%%%%%%%%%%
PyQBench can benchmark NISQ devices by verifying their capability of
discriminating between two von Neumann measurements. PyQBench offers a simplified, ready-to-use,
command line interface (CLI) for running benchmarks using a predefined parametrized Fourier
family of measurements. For more advanced scenarios, PyQBench offers a way of employing user-defined
measurements instead of predefined ones.
\section{Conflict of Interest}
We wish to confirm that there are no known
conflicts of interest associated with this publication and there has been no
significant financial support for this work that could have influenced its out-
come.


\section*{Acknowledgements}


This work is  supported by
the project “Near-term quantum computers Challenges, optimal implementations and applications” under Grant Number POIR.04.04.00-00-17C1/18-00, which is carried out within the Team-Net programme of the Foundation for Polish Science co-financed by the European Union under the European Regional Development Fund.
PL is also a holder of European Union scholarship through the European Social Fund,
grant InterPOWER (POWR.03.05.00-00-Z305).


\begin{thebibliography}{00}
\bibitem{preskill} Preskill, John. "Quantum Computing in the NISQ era and beyond." Quantum 2 (2018): 79.
\bibitem{rigetti} The web resource at \url{https://www.rigetti.com/}. Accessed on 2023-02-18.
\bibitem{ibmq} The web resource at \url{https://www.ibm.com/quantum}. Accessed on 2023-02-18.
\bibitem{oxforf} The web resource at \url{http://oxfordquantum.org/}. Accessed on 2023-02-18.
\bibitem{ionq} The web resource at \url{https://ionq.com/}. Accessed on 2023-02-18. 
\bibitem{xanadu} The web resource at \url{https://www.xanadu.ai/}. Accessed on 2023-02-18.
\bibitem{dwave} The web resource at \url{https://www.dwavesys.com/}. Accessed on 2023-02-18.
\bibitem{quera} The web resource at \url{https://www.quera.com/}. Accessed on 2023-02-18.
\bibitem{sdk} The web resource at \url{https://docs.rigetti.com/qcs/}. Accessed on 2023-02-18.
\bibitem{pyquil} The web resource at \url{https://pyquil-docs.rigetti.com/en/stable/}. Accessed on 2023-02-18.
\bibitem{qiskit} The web resource at \url{https://qiskit.org/}. Accessed on 2023-02-18.
\bibitem{ibmqplatform} The web resource at \url{https://quantum-computing.ibm.com/}. Accessed on 2023-02-18.
\bibitem{amazon} The web resource at \url{https://aws.amazon.com/braket/}. Accessed on 2023-02-18.
\bibitem{zapata} The web resource at \url{https://www.zapatacomputing.com/orquestra-platform/}. Accessed on 2023-02-18.
\bibitem{preskillnew} Preskill, J. (2021). Quantum computing 40 years later. arXiv preprint arXiv:2106.10522.
\bibitem{knill2008randomized}
Knill, E., Leibfried, D., Reichle, R., Britton, J., Blakestad, R. B., Jost, J. D., ...  Wineland, D. J. (2008). Randomized benchmarking of quantum gates. Physical Review A, 77(1), 012307.	
\bibitem{cross2019validating}
Cross, A. W., Bishop, L. S., Sheldon, S., Nation, P. D., Gambetta, J. M. (2019). Validating quantum computers using randomized model circuits. Physical Review A, 100(3), 032328.
\bibitem{moll2018quantum}
Moll, N., Barkoutsos, P., Bishop, L. S., Chow, J. M., Cross, A., Egger, D. J., ...  Temme, K. (2018). Quantum optimization using variational algorithms on near-term quantum devices. Quantum Science and Technology, 3(3), 030503.
\bibitem{pelofske2022volume} Pelofske, E., B{\"a}rtschi, A., Eidenbenz, S. (2022). Quantum volume in practice: What users can expect from NISQ devices. arXiv preprint arXiv:2203.03816.
\bibitem{arute2019quantum}Arute, F., Arya, K., Babbush, R., Bacon, D., Bardin, J. C., Barends, R., ... Martinis, J. M. (2019). Quantum supremacy using a programmable superconducting processor. Nature, 574(7779), 505-510.
\bibitem{neill2018blueprint}
Neill, C., Roushan, P., Kechedzhi, K., Boixo, S., Isakov, S. V., Smelyanskiy, V., ...  Martinis, J. M. (2018). A blueprint for demonstrating quantum supremacy with superconducting qubits. Science, 360(6385), 195-199.
\bibitem{liu2022sampling} 	Liu, Y., Otten, M., Bassirianjahromi, R., Jiang, L.,  Fefferman, B. (2021). Benchmarking near-term quantum computers via random circuit sampling. arXiv preprint arXiv:2105.05232.
\bibitem{knill2007randomized} Knill, E., Leibfried, D., Reichle, R., Britton, J., Blakestad, R. B., Jost, J. D., ... Wineland, D. J. (2008). Randomized benchmarking of quantum gates. Physical Review A, 77(1), 012307.
\bibitem{wallman2014randomized} Wallman, J. J.,  Flammia, S. T. (2014). Randomized benchmarking with confidence. New Journal of Physics, 16(10), 103032.
\bibitem{helsen2022general} Helsen, J., Roth, I., Onorati, E., Werner, A. H.,  Eisert, J. (2022). General framework for randomized benchmarking. PRX Quantum, 3(2), 020357.
\bibitem{cornelissen2021scalable} Cornelissen, A., Bausch, J.,  Gilyén, A. (2021). Scalable benchmarks for gate-based quantum computers. arXiv preprint arXiv:2104.10698.
\bibitem{puchala2018strategies} Puchała, Zbigniew, et al. "Strategies for
optimal single-shot discrimination of quantum measurements." Physical Review A
98.4 (2018): 042103.
\bibitem{helstrom1976quantum} Helstrom, C. W. (1969). "Quantum detection and estimation theory." Journal of Statistical Physics, 1(2), 231-252.
\bibitem{mthree} The web resource at \url{https://qiskit.org/documentation/partners/mthree/stubs/mthree.M3Mitigation.html}. Accessed on 2023-02-10.
\bibitem{mthreepublication} Nation, P. D., Kang, H., Sundaresan, N.,  Gambetta, J. M. (2021). Scalable mitigation of measurement errors on quantum computers. PRX Quantum, 2(4), 040326.
\bibitem{numericalrangle} Murnaghan, F. D. (1932). On the field of values of a square matrix. Proceedings of the National Academy of Sciences, 18(3), 246-248.
\bibitem{nr} Lewandowska, Paulina and others. The web resource at \url{https://numericalshadow.org/}. Accessed on 2022-10-02.
\bibitem{watrous2021simplier} Watrous, J. (2012). Simpler semidefinite programs for completely bounded norms. arXiv preprint arXiv:1207.5726.
\bibitem{lewandowska2021certification} Lewandowska, P., Krawiec, A., Kukulski, R., Pawela, Ł.,  Puchała, Z. (2021). On the optimal certification of von Neumann measurements. Scientific Reports, 11(1), 3623.
\bibitem{watrous} Watrous, John (2018). The theory of quantum information. Cambridge university press.
\bibitem{hausdorff} Hausdorff, Felix. "Der wertvorrat einer bilinearform." Mathematische Zeitschrift 3.1 (1919): 314-316.
\bibitem{toeplitz} Toeplitz, Otto. "Das algebraische Analogon zu einem Satze von Fejér." Mathematische Zeitschrift 2.1 (1918): 187-197.



	\todo[inline]{do wykorzystania cite}

	\bibitem{supermarq} Tomesh, T., Gokhale, P., Omole, V., Ravi, G. S., Smith, K. N., Viszlai, J., ...  Chong, F. T. (2022, April). Supermarq: A scalable quantum benchmark suite. In 2022 IEEE International Symposium on High-Performance Computer Architecture (HPCA) (pp. 587-603). IEEE.
	\bibitem{mqt2022} Quetschlich, N., Burgholzer, L., Wille, R. (2022). MQT Bench: Benchmarking software and design automation tools for quantum computing. arXiv preprint arXiv:2204.13719.

\bibitem{quark2022} Finžgar, J. R., Ross, P., Hölscher, L., Klepsch, J.,  Luckow, A. (2022, September). QUARK: A framework for quantum computing application benchmarking. In 2022 IEEE International Conference on Quantum Computing and Engineering (QCE) (pp. 226-237). IEEE.
\bibitem{michielsen2017benchmarking} Michielsen, Kristel, et al. "Benchmarking
gate-based quantum computers." Computer Physics Communications 220 (2017):
44-55.

\bibitem{zhukov2019quantum} Zhukov, A. A., et al. "Quantum communication
protocols as a benchmark for programmable quantum computers." Quantum
Information Processing 18.1 (2019): 1-23.
\bibitem{hamilton2018generative} Hamilton, Kathleen E., Eugene F. Dumitrescu,
and Raphael C. Pooser. "Generative model benchmarks for superconducting
qubits." Physical Review A 99.6 (2019): 062323.
\bibitem{benedetti2018generative} Benedetti, Marcello, et al. "A generative
modeling approach for benchmarking and training shallow quantum circuits." npj
Quantum Information 5.1 (2019): 1-9.









\end{thebibliography}


%\section*{Current executable software version}
%\label{}
%
%Ancillary data table required for sub version of the executable software: (x.1,
%x.2 etc.) kindly replace examples in right column with the correct information
%about your executables, and leave the left column as it is.
%
%\begin{table}[!h]
%\begin{tabular}{|l|p{6.5cm}|p{6.5cm}|}
%\hline
%\textbf{Nr.} & \textbf{(Executable) software metadata description} &
%\textbf{Please fill in this column} \\
%\hline
%S1 & Current software version & For example 1.1, 2.4 etc. \\
%\hline
%S2 & Permanent link to executables of this version  & For example:
%$https://github.com/combogenomics/$ $DuctApe/releases/tag/DuctApe-0.16.4$ \\
%\hline
%S3 & Legal Software License & List one of the approved licenses \\
%\hline
%S4 & Computing platforms/Operating Systems & For example Android, BSD, iOS,
%Linux, OS X, Microsoft Windows, Unix-like , IBM z/OS, distributed/web based
%etc. \\
%\hline
%S5 & Installation requirements \& dependencies & \\
%\hline
%S6 & If available, link to user manual - if formally published include a
%reference to the publication in the reference list & For example:
%$http://mozart.github.io/documentation/$ \\
%\hline
%S7 & Support email for questions & \\
%\hline
%\end{tabular}
%\caption{Software metadata (optional)}
%\label{}
%\end{table}

\appendix
\section{Mathematical preliminaries} \label{app:preliminaries}

Let $M_{d_1,d_2}$ be the set of all matrices of dimension $d_1 \times d_2$ over
the field $\mathbb{C}$. For  simplicity, square matrices will be denoted by
$M_d$.
%The subset of $M_d$ consisting of Hermitian matrices of dimension $d$
%will  be  denoted  by $\HH_d$,  while  the  set  of  positive semidefinite
%matrices of dimension $d$ by $\HH_d^+$.
By $\Omega_d$, we will denote the set of quantum states, that is
positive semidefinite operators having trace equal to one.
The subset of $M_d$ consisting of unitary matrices will be denoted
by $\UU_d$, while its subgroup of diagonal unitary operators will be denoted by
$\DD \UU_d$.
%An operator $A = \left( a_{i,j}\right)_{i,j} \in M_d$ is said to be a stochastic matrix if $a_{i,j} \ge 0$   and $\sum_{i} a_{i,j} = 1$, whereas an operator $A = \left( a_{i,j}\right)_{i,j} \in M_d$ is said to be a double stochastic matrix if $A$ is a stochastic matrix and $\sum_{j} a_{i,j} = 1$.


We will also need a linear mapping transforming $M_{d_1}$ into
$M_{d_2}$, which will be denoted
\begin{equation}
\Phi: M_{d_1 } \rightarrow M_{d_2}.
\end{equation}
There
exists a bijection between the set of linear mappings $\Phi$ and the set of matrices $M_{d_1d_2}$,  known as the Choi-Jamio{\l}kowski isomorphism.
For a given linear mapping $\Phi$ the corresponding Choi operator $J(\Phi)$ is explicitly written as
\begin{equation}
J(\Phi) \coloneqq \sum_{i,j=0}^{d- 1} \Phi(\ketbra{i}{j}) \otimes \ketbra{i}{j}. \end{equation}

We introduce a special subset of all mappings $\Phi$, called quantum channels, which are completely positive
and trace preserving (CPTP).
In this work we will consider a special class of quantum channels, called unitary channels.  A
channel
$\Phi_{U}$ is said to be a unitary channel if it has the following form $\Phi_U(\cdot) = U \cdot U^\dagger$ for any $U \in
\UU_d$.


The action of
von Neumann measurement $\PP_{U}$ on some state $\rho \in \Omega_d$ can be
seen as  a measure-and-prepare quantum channel as follows \begin{equation}
\PP_{U} : \rho \rightarrow \sum_{i=0}^{d-1} \bra{u_i} \rho \ket{u_i} \proj{i}.
\end{equation}
Moreover, observe that each von Neumann measuement $\PP_{U}$ poses a  composition of a unitary channel $\Phi_{U^\dagger}$ and the maximally dephasing channel $\Delta$, that means $\PP_{U} = \Delta \circ \Phi_{U^\dagger}$.

We need to also briefly discuss about the distance between unitary channels and von Neumann measurements. From \cite[Theorem 1]{puchala2018strategies}, the distance between measurements $\PP_U$ and
$\PP_\Id$ ie equal to
\begin{equation}
\|\PP_U - \PP_\Id\|_\diamond = \min_{E \in \diaguni_d} \|\Phi_{UE} -
\Phi_\Id\|_\diamond,
\end{equation} whereas to express the distance between unitary channels, we need to introduce the notion of numerical range \cite{numericalrangle}. The set \begin{equation}
W(A) =\{\bra{x}A\ket{x}: \ket{x} \in
\mathbb{C}^d, \;
\;\braket{x}{x}=1\}.
\end{equation}
is called numerical range of  a matrix $A \in M_d$.
The detailed properties of the numerical range and its generalizations we can see on the website~\cite{nr}.
Due to the definition of $W(A)$, the distance between two unitary channels $\Phi_{U} $ and $\Phi_\Id$
can be written as
\begin{equation}
\| \Phi_U  - \Phi_{\1} \|_\diamond = 2 \sqrt{1-\nu^2},
\end{equation}
where $\nu = \min_{x \in W(U^\dagger)} |x|  $.



\section{Discrimination task for Hadamard gate}\label{app:hadamard}
For the discrimination task between von Neumann measurements $\PP_{U}$ and $\PP_\Id$, where $U = H$ (the Hadamard gate) the key is to calculate the diamond norm $\| \mathcal{P}_H - \PP_\Id \|_\diamond$ and 
determine the discriminator $\ket{\psi_0}$.
Using semidefinite programming \cite{watrous2021simplier}, we obtain 
\begin{equation}
\| \mathcal{P}_H - \PP_\Id \|_\diamond = \sqrt{2}. 
\end{equation}
From \cite{lewandowska2021certification} we have 
\begin{equation}
\| \PP_{H} - \PP_{\Id} \|_\diamond = \| \Phi_{HE_0} - \Phi_{\Id}\|_\diamond,
\end{equation}
where $\Phi_{U}$ is a unitary channel and 
 $E_0$ 
is of the form
\begin{equation}
E_0 = \frac{1}{2} \left( \begin{matrix} 
1 + i & 0  \\  0 & -1-i 
\end{matrix} \right). 
\end{equation}
Next, in order to construct the discriminator $\ket{\psi_0}$ we use Lemma 5 and the proof of Theorem 1 in \cite{puchala2018strategies}. We show that there exist states 
 $\rho_1 $  and $\rho_2$ of the form $ \rho_1  = \frac{1}{2} \left( \begin{matrix} 
 1  & i  \\  -i & 1
 \end{matrix} \right)  $  and $\rho_2 = \frac{1}{2} \left( \begin{matrix} 
 1 & -i \\  i & 1 
 \end{matrix} \right), $ respectively. Thus, we construct the quantum state $\rho_0$ as follows:
 \begin{equation}
 \rho_0 = \frac{1}{2} \rho_1 + \frac{1}{2} \rho_2 = \frac{1}{2} \left( \begin{matrix} 
 1  &  0  \\  0  & 1
 \end{matrix} \right).
 \end{equation}
 According to the Lemma 5 and the proof of Theorem 1 in \cite{puchala2018strategies} we assume that \begin{equation}
 \ket{\psi_0} = | \rho_0 \rangle \rangle. 
 \end{equation}
 It direcly implies that 
 \begin{equation}
 \ket{\psi_0} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11}).  \end{equation}
 Next, from Holevo-Helstrom theorem~\cite{watrous}, we determine the final measurement $\PP_{V_i}$. 
 Let us consider \begin{equation}
 X = \left(\PP_{H} \otimes \Id \right)(\proj{\psi_0}) - \left(\PP_{\Id} \otimes \Id \right) (\proj{\psi_0})
  \end{equation}
 From the Hahn-Jordan decomposition, let us note
 \begin{equation}
 X = P - Q
 \end{equation}
 where $P, Q \ge 0 $.
 Let us define projectors $\Pi_P$ and $\Pi_Q$ onto  $\text{im}(P)$ and $\text{im}(Q)$,
 respectively. Observe, that $P $ and $Q$ are block-diagonal.  Then,  $\Pi_P$ and $\Pi_Q$ have the following forms
 \begin{equation}
 \Pi_P = \left(\begin{array}{cc}\proj{x_p}&0\\0&\proj{y_p}\end{array}\right)
 \end{equation}
 and
 \begin{equation}
 \Pi_Q = \left(\begin{array}{cc}\proj{x_q}&0\\0&\proj{y_q}\end{array}\right).
 \end{equation}
 Hence, we define $V_0$ as
 \begin{equation}
 \begin{cases} V_0 \ket{x_p} = \ket{0} \\ V_0 \ket{x_q} = \ket{1} \end{cases}
 \end{equation}
 and $V_1$ as
 \begin{equation}
 \begin{cases}
 V_1 \ket{y_p} = \ket{0} \\
 V_1 \ket{y_q} = \ket{1}
 \end{cases}.
 \end{equation}
 For the discrimination task between $\PP_{H}$ and $\PP_{\Id}$ the explicit form of $V_0$ and $V_1$ is given as
 follows: \todo[inline]{udostepniamy ten plik nb z obliczeniami? (see also \texttt{one-qubit.nb}}
 \begin{equation}
 V_0 =
 \left(\begin{array}{cc} \alpha & -\beta\\ \beta & \alpha \end{array}\right),
 \end{equation}
 and \begin{equation}
 V_1 =
 \left(\begin{array}{cc} -\beta & \alpha \\ \alpha & \beta \end{array}\right),
 \end{equation}
 where \begin{equation}
 \alpha = \frac{\sqrt{2 - \sqrt{2}}}{2} = \cos\left( \frac{3}{8} \pi \right),
 \end{equation}
 \begin{equation}
 \beta  = \frac{\sqrt{2  + \sqrt{2}}}{2} = \sin\left( \frac{3}{8} \pi \right).
 \end{equation}
 
\section{Optimal probability for parametrized Fourier family} \label{app:optimal-probability}
Let us focus on single-qubit von Neumann measurements $\PP_\1$ and $\PP_U$.
Assume that the unitary matrix $U$ is of the form
\begin{equation}
U = H
\left(\begin{array}{cc}1&0\\0&e^{i \phi}\end{array}\right)  H^\dagger
\end{equation}
%\begin{equation}
%U = H \diag (1, \ee^{\ii \phi}) H^\dagger,
%\end{equation}
where $H$ is the Hadamard matrix of dimension two and $\phi \in [0, 2 \pi)$.
In this section we present theoretical probability of correct
discrimination between these measurements. To do that, we will present an auxiliary lemma.
\begin{lemma}\label{lemma:min-e-optimal}
	Let $U = H \diag(1, e^{i \phi}) H^\dagger$, $\phi \in [0, 2\pi)$ and	let
	$\Phi_U$ and $\Phi_\Id$ be two unitary channels. Then, the following equation holds
	\begin{equation}
	\min_{E \in \diaguni_2} \|\Phi_{UE} -
	\Phi_\Id\|_\diamond = \|\Phi_{U} -
	\Phi_\Id\|_\diamond,
	\end{equation}
\end{lemma}

\begin{proof} Recall that the distance between two unitary channels is given by
	$
	\| \Phi_U  - \Phi_{\1} \|_\diamond = 2 \sqrt{1-\nu^2},
	$
	where $\nu = \min_{x \in W(U^\dagger)} |x|  $ for any $U \in \mathcal{U}_d$.
	For $U = H
	\left(\begin{array}{cc}1&0\\0&e^{i \phi}\end{array}\right)  H^\dagger$ the readers briefly observe that  $\nu^2 = 1 - \frac{|1 - e^{-i \phi} |^2 }{4} = 1 - \frac{|1 - e^{i \phi} |^2 }{4}$. So,
	\begin{equation}
	\|  \Phi_U  - \Phi_{\1} \|_\diamond = | 1 - e^{i \phi} |.
	\end{equation}
	It implies that it is enough to prove  \begin{equation}
	\min_{E \in \diaguni_2} \|\Phi_{UE} -
	\Phi_\Id\|_\diamond  = | 1 - e^{i \phi} |.
	\end{equation}
	%		It implies that we can prove  equivalently  the following condition
	%		\begin{equation}
	%		\max_{E \in \diaguni_2 } \nu_{UE} = \nu_U
	%		\end{equation}
	This condition is equivalent to show
	\begin{equation}
	\max_{E \in \diaguni_2 } \nu_{E} = \frac{|1 + e^{i \phi} | }{2},
	\end{equation}
	where $\nu_E = \min_{x \in W(U^\dagger E)} |x|. $

	%	For simplify notation, let 	$ \nu \coloneqq \max_{E \in \diaguni_2 } \nu_{E} $.
	The celebrated Hausdorf-T{\"o}plitz theorem~\cite{hausdorff, toeplitz} states that
	$W(A)$ of any matrix $A \in M_d$ is a convex set, and therefore we have
	\begin{equation}
	W(A) = \{ \tr(A \rho): \rho \in \Omega_d\}.
	\end{equation}
	So, we can assume that
	\begin{equation}
	\min_{\ket{x} \in \mathbb{C}^2:   \proj{x} = 1} |\bra{x}U^\dagger\ket{x}| =
	\min_{\rho \in \Omega_2} |\tr(U^\dagger\rho)|.
	\end{equation}
	Then, we have
	\begin{equation}
	\max_{E \in \diaguni_2 } \nu_{E}  = \max_{E \in \diaguni_2 }  \min_{\rho \in
		\Omega_2} \left| \tr \left( \rho U E \right) \right|.
	\end{equation}
	For that, our task is reduced to show that
	\begin{equation}
	\forall_{E \in \diaguni_2} \,\, | \tr \left(\rho U E\right) | \le \max_{E \in \diaguni_2 } \nu_{E}.
	\end{equation}



	Let us define $E = \left(\begin{array}{cc}E_0&0\\0&E_1\end{array}\right)  $
	and take $\rho =
	\left(\begin{array}{cc}\frac{1}{2}&0\\0&\frac{1}{2}\end{array}\right) $.
	From spectral theorem, let us decompose $U$ as
	\begin{equation}
	U= \lambda_0 \ketbra{x_0}{x_0} + \lambda_1 \ketbra{x_1}{x_1},
	\end{equation}
	where  for eigenvalue $\lambda_0 = 1$, the corresponding
	eigenvector is
	of the form $\ket{x_0} = \left[\begin{array}{c}\frac{1}{\sqrt{2}}\\\frac{1}{\sqrt{2}}\end{array}\right]
	$,
	whereas for  $\lambda_1= e^{i \phi}$ we have $\ket{x_1} = \left[\begin{array}{c}\frac{1}{\sqrt{2}}\\-\frac{1}{\sqrt{2}}\end{array}\right]
	$.
	Then, we have
	\begin{equation}
	\begin{split}
	& \forall E \in \diaguni_2 \,\,\, | \tr (\rho U E) | = \frac{1}{2}  \left| \tr \left(
	H \diag(1, e^{i\phi}) H^\dagger E \right) \right| =  \\ &
	\frac{1}{2} \left| \tr\left((   \proj{x_0} +e^{i \phi}\proj{x_1} ) E \right)
	\right|  =
	\frac{1}{2} \left|  \bra{x_0} E \ket{x_0} +  e^{i \phi}\bra{x_1} E \ket{x_1}
	\right| = \\&
	\frac{1}{2} \left| \frac{E_0 + E_1}{2} + e^{i \phi } \frac{E_0+E_1}{2} \right|
	=
	\frac{\left| 1+ e^{i \phi } \right|}{2} \left| \frac{E_0 + E_1}{2} \right| \le
	\max_{E \in \diaguni_2 } \nu_{E},
	\end{split}
	\end{equation}
	which completes the proof.
\end{proof}



\begin{theorem}\label{th:probability}
	The optimal probability of correct discrimination between von Neumann
	measurements $\PP_U$ and $\PP_{\Id}$ for $U = H \diag(1, e^{i \phi}) H^\dagger$,
	where $\phi \in [0, 2\pi)$ is given by
	\begin{equation}
	p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{1}{2} + \frac{|1 - e^{i \phi}  |}{4} .
	\end{equation}
\end{theorem}



\begin{proof}
	From Holevo-Helstrom theorem, we obtain
	\begin{equation}
	p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{1}{2} + \frac{1}{4} \| \PP_{U} - \PP_{\Id} \|_\diamond.
	\end{equation}
	From~\cite[Theorem 1]{puchala2018strategies}, we have
	\begin{equation}
	\|\PP_U - \PP_\Id\|_\diamond = \min_{E \in \diaguni_d} \|\Phi_{UE} -
	\Phi_\Id\|_\diamond.
	\end{equation}
	From Lemma~\ref{lemma:min-e-optimal},  we know that for
	$U =  H \diag(1, e^{i \phi}) H^\dagger$,  it also holds that
	\begin{equation}
	\min_{E \in \diaguni_2} \|\Phi_{UE} -
	\Phi_\Id\|_\diamond = \|\Phi_{U} -
	\Phi_\Id\|_\diamond,
	\end{equation} which is exactly equal to
	\begin{equation}
	\|\Phi_{U} -
	\Phi_\Id\|_\diamond = 2\sqrt{1 - \nu^2} = |1-e^{i   \phi }|.
	\end{equation}
	%	Finally, we obtain that
	%	\begin{equation}
	%	\| \PP_{U} - \PP_{\Id} \|_\diamond =  |1-e^{i   \phi }|.
	%	\end{equation}
	It implies that
	\begin{equation}
	p_{\text{succ}}(\PP_{U}, \PP_{\Id}) = \frac{1}{2} + \frac{|1-e^{i \phi}|}{4},
	\end{equation} which completes the proof.
\end{proof}

\section{Optimal discrimination strategy for parametrized Fourier family} \label{app:optimal-strategy}


In this Appendix we create the optimal
theoretical strategy of  discrimination between $\PP_{U}$ and $\PP_{\Id}$.
To indicate the optimal strategy, we will present two propositions. The first one is concentrated around the discriminator as the optimal input state of discrimination strategy, whereas the second one describes the optimal final measurement.


\begin{proposition}\label{prop-discrim}
	Consider the problem of discrimination between von Neumann measurements $\PP_U$
	and $\PP_\1$, $U = H\diag(1, e^{i \phi}) H^\dagger $ and $\phi \in [0,
	2\pi)$.  The  discriminator has the form
	\begin{equation}
	\ket{\psi_{0}} = \frac{1}{\sqrt{2}} |\Id_2 \rangle \rangle.
	\end{equation}
\end{proposition}

\begin{proof}
	Let $U = H\diag(1, e^{i \phi}) H^\dagger, \phi \in [0,
	2\pi)$ be decomposed as
	\begin{equation}
	U= \lambda_1 \ketbra{x_1}{x_1} + \lambda_2 \ketbra{x_1}{x_2},
	\end{equation}
	where  for eigenvalue $\lambda_1 = 1$, the corresponding
	eigenvector is
	of the form $\ket{x_1} = \left[\begin{array}{c}\frac{1}{\sqrt{2}}\\\frac{1}{\sqrt{2}}\end{array}\right]
	$,
	whereas for  $\lambda_2 = e^{i \phi}$ we have $\ket{x_2} = \left[\begin{array}{c}\frac{1}{\sqrt{2}}\\-\frac{1}{\sqrt{2}}\end{array}\right]
	$.
	For Hermitian-preserving maps \cite{watrous} the diamond norm may be expressed as
	\begin{equation}
	\| \Phi  \|_\diamond =  \max_{\rho \in \Omega_d} \| \left( \Id \otimes \sqrt{\rho} \right) J(\Phi)  \left( \Id \otimes \sqrt{\rho} \right)  \|_1.  \end{equation}
	Hence, we obtain
	\begin{equation}
	\begin{split}
	\| \PP_{U} - \PP_{\Id}  \|_\diamond
	& =  \max_{\rho \in \Omega_2} \left\| \left( \Id \otimes \sqrt{\rho} \right)
	J(\PP_{U} - \PP_{\Id} )  \left( \Id \otimes \sqrt{\rho} \right)  \right\|_1
	\\
	& =  \max_{\rho \in \Omega_2} \left\| \left( \Id \otimes \sqrt{\rho} \right)
	\sum_{i=0}^{1} \proj{i} \otimes \left( \proj{u_i} - \proj{i} \right)^\top
	\right\|_1  \\
	& = \max_{\rho \in \Omega_2} \left\| \sum_{i=0}^{1} \proj{i} \otimes
	\sqrt{\rho}  \left( \proj{u_i} - \proj{i} \right)^\top \sqrt{\rho}  \right\|_1
	\\
	& = \max_{\rho \in \Omega_2} \left\| \sum_{i=0}^{1}\sqrt{\rho}  \left(
	\proj{u_i} - \proj{i} \right)^\top \sqrt{\rho}  \right\|_1. 
	\end{split}
	\end{equation}
	One can prove that for all $\alpha, \beta \ge 0 $, and unit vectors $\ket{x},
	\ket{y}$ the following equation holds~\cite{watrous}
	\begin{equation}
	\| \alpha \proj{x} - \beta\proj{y} \|_1 = \sqrt{(\alpha + \beta)^2 - 4\alpha
		\beta |\braket{x}{y}|^2}.
	\end{equation}
	By taking $\ket{x} = \frac{\sqrt{\rho} \ket{\bar{u_i}}}{\| \sqrt{\rho}
		\ket{\bar{u_i}} \|}$ and $ \ket{y} = \frac{\sqrt{\rho} \ket{i}}{\|\sqrt{\rho}
		\ket{i} \|}$ we have
	\begin{equation}
	\| \PP_{U} - \PP_{\Id}  \|_\diamond  = \max_{\rho \in \Omega_2}
	\sum_{i=0}^{1} \sqrt{\left( \bra{u_i} \rho \ket{u_i} + \bra{i} \rho \ket{i
		}\right)^2 - 4 | \bra{u_i} \rho \ket{i} |^2}.
	\end{equation}
	Let us take  $\rho_0 =   \frac{1}{2}
	\left(\begin{array}{cc}1&0\\0&1\end{array}\right)  $,   we obtain
	\begin{equation}
	\begin{split}
	||\mathcal{P}_U - \mathcal{P}_{\1}||_\diamond
	&= \sum_{i=0}^1
	\sqrt{\left(\bra{u_i}\rho_0\ket{u_i} + \bra{i} \rho_0 \ket{i} \right)^2 -
		4|\bra{i}\rho_0\ket{u_i}|^2}  \\
	&= \sum_{i=0}^1  \sqrt{ 1 -  \left| \bra{i}  U \ket{i }\right|^2}
	\\
	&=\sum_{i=0}^1  \sqrt{1 -  \left| 1 \cdot \bra{i} \proj{u_1}
		\ket{i} + e^{i \phi} \cdot\bra{i}  \proj{u_2}\ket{i}\right|^2} \\
	&= \sum_{i=0}^1
	\sqrt{1 -\left| \frac{1+ e^{i \phi}}{2}\right|^2 }
	= 2 \sqrt{1 -\left| \frac{1+e^{i \phi}}{2}\right|^2 } \\
	&= |1-e^{i \phi }|.
	\end{split}
	\end{equation}
	Observe that
	\begin{equation}
	\begin{split}
 \| \left( \Id \otimes \sqrt{\rho} \right) J(\PP_{U} - \PP_{\Id} )  \left(
	\Id \otimes \sqrt{\rho} \right) \|_1 = \left\| ( (\PP_{U} - \PP_\Id) \otimes \Id) \left(  | \sqrt{\rho}^\top
	\rangle \rangle \langle \langle \sqrt{\rho}^\top | \right) \right\|_1.
	\end{split}
	\end{equation}
	Due to that, we know
	that $\left| \sqrt{\rho_0}^{\top} \rangle \right\rangle$ equals $\frac{1}{\sqrt{2} } |
	\Id_2 \rangle \rangle$ is the discriminator of the problem
	of discrimination between
	$\PP_{\Id} $ and $\PP_U$ for
	$ U =  H \diag(1, e^{i \phi}) H^\dagger$ (from definition of diamond norm).      Hence, we obtain that \begin{equation}
	\ket{\psi_{0}} =  \frac{1}{\sqrt{2} } |
	\Id_2 \rangle \rangle,
	\end{equation}
	which completes the proof.
\end{proof}


\begin{proposition}\label{prop:optimal-measurement}
	Consider the problem of discrimination between von Neumann measurements $\PP_U$
	and $\PP_\1$, $U = H\diag(1, e^{i \phi}) H^\dagger $ and $\phi \in [0,
	2\pi)$.
	The   controlled unitaries $V_0$ and $V_1$
	have the form
	\begin{equation}
	V_0 = \left(\begin{array}{cc}i \sin\left( \frac{\pi - \phi}{4} \right)&-i
	\cos\left( \frac{\pi - \phi}{4} \right)\\ \cos\left( \frac{\pi -
		\phi}{4}\right)& \sin\left( \frac{\pi - \phi}{4} \right)\end{array}\right),
	\end{equation}
	and
	\begin{equation}
	V_1 = \left(\begin{array}{cc}-i \cos\left(\frac{\pi - \phi}{4}\right) &i
	\sin\left( \frac{\pi - \phi}{4}\right)\\\sin\left( \frac{\pi - \phi}{4} \right)
	&  \cos\left( \frac{\pi - \phi}{4} \right) \end{array}\right).
	\end{equation}
\end{proposition}

\begin{proof}
	From Proposition~\ref{prop-discrim} we obtain the exact form of discriminator given by
	\begin{equation}
	\ket{\psi_0}  = \frac{1}{\sqrt{2}} |\Id_2
	\rangle \rangle.
	\end{equation}
	Repeating the scheme used to distinguish the von Neumann measurements in the Hadamard basis (see \ref{app:hadamard}), we use the Hahn Jordan decomposition and then we create the projective operators into the positive and negative part of $X$ matrix.
%	From Holevo-Helstrom theorem~\cite{watrous}, we constrain a final optimal measurement $\PP_{V_i}$.
%	Let us define
%	\begin{equation}
%	X  = \left( \PP_U \otimes \Id_2 \right)(\proj{\psi_0}) -  \left( \PP_\Id
%	\otimes \Id_2 \right)(\proj{\psi_0}).
%	\end{equation}
%	
%	
%	
%	From the Hahn-Jordan decomposition, let us note
%	\begin{equation}
%	X = P - Q
%	\end{equation}
%	where $P, Q \ge 0 $.
%	Let us define projectors $\Pi_P$ and $\Pi_Q$ onto  $\text{im}(P)$ and $\text{im}(Q)$,
%	respectively. Observe, that $P $ and $Q$ are block-diagonal.  Then,  $\Pi_P$ and $\Pi_Q$ have the following forms
%	\begin{equation}
%	\Pi_P = \left(\begin{array}{cc}\proj{x_p}&0\\0&\proj{y_p}\end{array}\right)
%	\end{equation}
%	and
%	\begin{equation}
%	\Pi_Q = \left(\begin{array}{cc}\proj{x_q}&0\\0&\proj{y_q}\end{array}\right).
%	\end{equation}
%	Hence, we define $V_0$ as
%	\begin{equation}
%	\begin{cases} V_0 \ket{x_p} = \ket{0} \\ V_0 \ket{x_q} = \ket{1} \end{cases}
%	\end{equation}
%	and $V_1$ as
%	\begin{equation}
%	\begin{cases}
%	V_1 \ket{y_p} = \ket{0} \\
%	V_1 \ket{y_q} = \ket{1}
%	\end{cases}.
%	\end{equation}
%	For the discrimination task between $\PP_{U}$ and $\PP_{\Id}$, where $U = H
%	\diag(1, e^{i \phi })H$, 
	Hence, the explicit form of $V_0$ and $V_1$ is given as
	follows: \todo[inline]{udostepniamy ten plik nb z obliczeniami? (see also \texttt{one-qubit.nb}}
	\begin{equation}
	V_0 = \left(
	\begin{array}{cc}i \sin\left( \frac{\pi - \phi}{4} \right)&-i
	\cos\left( \frac{\pi - \phi}{4} \right)\\ \cos\left( \frac{\pi -
		\phi}{4}\right)& \sin\left( \frac{\pi - \phi}{4} \right)
	\end{array}
	\right),
	\end{equation}
and
	\begin{equation}
	V_1 = \left(\begin{array}{cc}-i \cos\left(\frac{\pi - \phi}{4}\right) &i
	\sin\left( \frac{\pi - \phi}{4}\right)\\\sin\left( \frac{\pi - \phi}{4}
	\right) &  \cos\left( \frac{\pi - \phi}{4} \right) \end{array}\right),
	\end{equation}
	where $\phi \in [0,2\pi)$.
\end{proof}


\section{Output YAML files} \label{app:example}
In this appendix we present examples of YAML's files obtained from synchronous ans asynchronous experiments. We will start at synchronous case.

\begin{lstlisting}[language=Python, caption=Defining experiment file]
type: discrimination-fourier
qubits:
	- target: 0
	  ancilla: 1
	- target: 1
	  ancilla: 2
angles:
	start: 0
	stop: 2 * pi
	num_steps: 3
gateset: ibmq
method: direct_sum
num_shots: 100
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Defining backend file]
name: ibmq_quito
asynchronous: false
provider:
	hub: ibm-q
	group: open
	project: main

\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Results (synchronous)]
metadata:
	experiments:
		type: discrimination-fourier
		qubits:
		- {target: 0, ancilla: 1}
		- {target: 1, ancilla: 2}
		angles: {start: 0.0, stop: 6.283185307179586, num_steps: 3}
		gateset: ibmq
		method: direct_sum
		num_shots: 100
	backend_description:
		name: ibmq_quito
		asynchronous: false
		provider: {group: open, hub: ibm-q, project: main}
data:
- target: 0
  ancilla: 1
  phi: 0.0
  results_per_circuit:
  - name: id
	histogram: {'00': 28, '01': 26, '10': 21, '11': 25}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.2637212373658018, '01': 0.25865061319892463, '10': 0.2067279352110304, '11': 0.2709002142242433}
  - name: u
	histogram: {'00': 30, '01': 16, '10': 28, '11': 26}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.2857378991684036, '01': 0.14975297832942433, '10': 0.28142307224788693, '11': 0.2830860502542851}
- target: 0
  ancilla: 1
  phi: 3.141592653589793
  results_per_circuit:
  - name: id
	histogram: {'00': 4, '01': 5, '10': 45, '11': 46}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.011053610583159325, '01': 0.02261276648026373, '10': 0.4593955619936729, '11': 0.5069380609429042}
  - name: u
	histogram: {'00': 56, '01': 43, '10': 1}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.5573987337172156, '01': 0.44424718645642625, '10': -0.0016459201736417181}
- target: 0
  ancilla: 1
  phi: 6.283185307179586
  results_per_circuit:
  - name: id
	histogram: {'00': 36, '01': 18, '10': 25, '11': 21}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.3488190312089973, '01': 0.17355281935572894, '10': 0.2505792064871127, '11': 0.22704894294816103}
  - name: u
	histogram: {'00': 32, '01': 27, '10': 24, '11': 17}
	mitigation_info:
		target: {prob_meas0_prep1: 0.052200000000000024, prob_meas1_prep0: 0.0172}
		ancilla: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
	mitigated_histogram: {'00': 0.3025357275361897, '01': 0.27413673119534815, '10': 0.24313373302688793, '11': 0.18019380824157433}
- target: 1
  ancilla: 2
  phi: 0.0
  results_per_circuit:
  - name: id
	histogram: {'00': 27, '01': 20, '10': 24, '11': 29}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.2594378169217188, '01': 0.19318893233269735, '10': 0.23035366874292057, '11': 0.3170195820026633}
  - name: u
	histogram: {'00': 31, '01': 24, '10': 23, '11': 22}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.30056875246775644, '01': 0.2438221628798003, '10': 0.22180309809696985, '11': 0.23380598655547338}
- target: 1
  ancilla: 2
  phi: 3.141592653589793
  results_per_circuit:
  - name: id
	histogram: {'00': 5, '01': 4, '10': 50, '11': 41}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.009552870928837118, '01': 0.007194089383161034, '10': 0.5236791012692514, '11': 0.4595739384187503}
  - name: u
	histogram: {'00': 41, '01': 51, '10': 3, '11': 5}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.4073387714165384, '01': 0.5614614121117936, '10': 0.006431862814564833, '11': 0.024767953657102992}
- target: 1
  ancilla: 2
  phi: 6.283185307179586
  results_per_circuit:
  - name: id
	histogram: {'00': 30, '01': 28, '10': 23, '11': 19}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.2868459834940102, '01': 0.2919564941384742, '10': 0.22466574543735374, '11': 0.19653177693016174}
  - name: u
	histogram: {'00': 15, '01': 20, '10': 36, '11': 29}
	mitigation_info:
		target: {prob_meas0_prep1: 0.05900000000000005, prob_meas1_prep0: 0.0202}
		ancilla: {prob_meas0_prep1: 0.07540000000000002, prob_meas1_prep0: 0.0528}
	mitigated_histogram: {'00': 0.1187719606657805, '01': 0.1962085394489247, '10': 0.3710195249988589, '11': 0.31399997488643583}
\end{lstlisting}
For the same experiment file, we use the flag \textit{asynchronous: true} to define asynchronous experiment.

\begin{lstlisting}[language=Python, caption=Backend file]
name: ibmq_quito
asynchronous: true
provider:
	hub: ibm-q
	group: open
	project: main

\end{lstlisting}
If backend is asynchronous, the output will contain intermediate data
containing, amongst others, job ids correlated with the circuit they
correspond to.

\begin{lstlisting}[language=Python, caption=Resolved results]
metadata:
	experiments:
		type: discrimination-fourier
		qubits:
		- {target: 0, ancilla: 1}
		- {target: 1, ancilla: 2}
		angles: {start: 0.0, stop: 6.283185307179586, num_steps: 3}
		gateset: ibmq
		method: direct_sum
		num_shots: 100
	backend_description:
		name: ibmq_quito
		asynchronous: true
		provider: {group: open, hub: ibm-q, project: main}
data:
- job_id: 63e7f17a17b7ed49ca24e05b
  keys:
  - [0, 1, id, 0.0]
  - [0, 1, u, 0.0]
  - [0, 1, id, 3.141592653589793]
  - [0, 1, u, 3.141592653589793]
  - [0, 1, id, 6.283185307179586]
  - [0, 1, u, 6.283185307179586]
  - [1, 2, id, 0.0]
  - [1, 2, u, 0.0]
  - [1, 2, id, 3.141592653589793]
  - [1, 2, u, 3.141592653589793]
  - [1, 2, id, 6.283185307179586]
  - [1, 2, u, 6.283185307179586]

\end{lstlisting}
Finally, if the status of jobs is DONE, we resolve the measurements from the
submitted jobs obtaining the following file.
\begin{lstlisting}[language=Python, caption=Results (asynchronous)]
metadata:
  experiments:
	type: discrimination-fourier
	qubits:
	- target: 0
	  ancilla: 1
	- target: 1
	  ancilla: 2
	angles:
	  start: 0.0
	  stop: 6.283185307179586
	  num_steps: 3
	gateset: ibmq
	method: direct_sum
	num_shots: 100
  backend_description:
	name: ibmq_quito
	asynchronous: true
	provider:
		group: open
		hub: ibm-q
		project: main
data:
- target: 0
  ancilla: 1
  phi: 0.0
  results_per_circuit:
  - name: id
	histogram:
		'00': 27
		'01': 28
		'10': 18
		'11': 27
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.254196166145997
		'01': 0.2790358060520916
		'10': 0.1732699847244092
		'11': 0.29349804307750227
  - name: u
	histogram:
		'00': 29
		'01': 17
		'10': 30
		'11': 24
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.2733793468261183
		'01': 0.1621115306717096
		'10': 0.3045273800167787
		'11': 0.2599817424853933
- target: 0
  ancilla: 1
  phi: 3.141592653589793
  results_per_circuit:
  - name: id
	histogram:
		'00': 3
		'01': 5
		'10': 37
		'11': 55
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.006189545789708441
		'01': 0.016616709640352317
		'10': 0.3675478279476653
		'11': 0.6096459166222741
  - name: u
	histogram:
		'00': 56
		'01': 42
		'10': 2
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.55731929321128
		'01': 0.43367489257574243
		'10': 0.009005814212977551
- target: 0
  ancilla: 1
  phi: 6.283185307179586
  results_per_circuit:
  - name: id
	histogram:
		'00': 18
		'01': 28
		'10': 30
		'11': 24
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.15258295844557557
		'01': 0.2829079190522524
		'10': 0.3071204587046501
		'11': 0.25738866379752195
  - name: u
	histogram:
		'00': 32
		'01': 28
		'10': 23
		'11': 17
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.052200000000000024
		prob_meas1_prep0: 0.0172
	  ancilla:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	mitigated_histogram:
		'00': 0.3026150836796529
		'01': 0.28491749668524724
		'10': 0.23230862145681827
		'11': 0.18015879817828173
- target: 1
  ancilla: 2
  phi: 0.0
  results_per_circuit:
  - name: id
	histogram:
		'00': 27
		'01': 16
		'10': 30
		'11': 27
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': 0.256742095057232
		'01': 0.15000257115061383
		'10': 0.29821012040758116
		'11': 0.29504521338457296
  - name: u
	histogram:
		'00': 34
		'01': 22
		'10': 25
		'11': 19
	mitigation_info:
	 target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': 0.3325088211394024
		'01': 0.22335261496979697
		'10': 0.2441636375921354
		'11': 0.19997492629866526
- target: 1
  ancilla: 2
  phi: 3.141592653589793
  results_per_circuit:
  - name: id
	histogram:
		'00': 3
		'01': 9
		'10': 51
		'11': 37
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': -0.016627023111853642
		'01': 0.06778554570877951
		'10': 0.53899887367658
		'11': 0.40984260372649417
  - name: u
	histogram:
		'00': 43
		'01': 45
		'10': 7
		'11': 5
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': 0.42955729968594086
		'01': 0.49336080079582095
		'10': 0.04937406434533623
		'11': 0.02770783517290191
- target: 1
  ancilla: 2
  phi: 6.283185307179586
  results_per_circuit:
  - name: id
	histogram:
		'00': 22
		'01': 19
		'10': 35
		'11': 24
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': 0.19592641048040849
		'01': 0.18787721420415215
		'10': 0.3590258049844047
		'11': 0.25717057033103463
  - name: u
		histogram:
		'00': 27
		'01': 24
		'10': 25
		'11': 24
	mitigation_info:
	  target:
		prob_meas0_prep1: 0.05900000000000005
		prob_meas1_prep0: 0.0202
	  ancilla:
		prob_meas0_prep1: 0.07540000000000002
		prob_meas1_prep0: 0.0528
	mitigated_histogram:
		'00': 0.25555866817587225
		'01': 0.2429501641251142
		'10': 0.24509293912212946
		'11': 0.2563982285768841
\end{lstlisting}

\end{document}
\endinput
%%
%% End of file `SoftwareX_article_template.tex'.
